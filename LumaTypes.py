from typing import Any, Callable, Union, LiteralString, NoReturn
from re import Pattern

EvaluatedType = Union["LumaInterpreter.InstancedLumaObject", int, str, dict]

class LumaInterpreter:
    _instance: "LumaInterpreter"
    env: "dict[str, EvaluatedType | LumaInterpreter.LumaFunction | LumaInterpreter.LumaClass]"
    localparams: list[dict[str, EvaluatedType]]
    LOGICAL_OPERATORS: list[str]
    OPERATORS: dict[str, str]
    REAL_OPERATORS: dict[str, Callable]
    PY_IMPL_CLASSES: list[str]
    NUMBER_RE: Pattern[str]
    LOGICAL_OP_RE: Pattern[str]
    SAVED_KEYWORDS: list[str]
    tb: list[tuple[int, str, str]]
    overloads: dict[str, list[Callable]]
    overrides: dict[str, list[Callable]]
    filename: str
    scopes: list[str]

    def __new__(cls) -> "LumaInterpreter": ...

    def run(self, program: str, filename: str) -> None: ...

    @staticmethod
    def getfirstword(line: str) -> str: ...

    def isnumber(self, data: str | int | float) -> bool: ...

    @staticmethod
    def reverse_list(r: list) -> list: ...
    
    def traceback(self) -> list[tuple[int, str, str]]: ...

    def realvalue(self, expr: str, includelist: bool = False) -> int | float | str | dict | dict[EvaluatedType, EvaluatedType] | None: ...

    @staticmethod
    def removetab(line: str) -> str: ...

    @staticmethod
    def preprocess(prog: str) -> str: ...

    def generaterandomvarname(self) -> str: ...

    def runimport(self, module: str, name: str) -> None: ...

    def runext(self, ext: str) -> None: ...

    def parse_py(self, token) -> "EvaluatedType | LumaInterpreter.LumaClass | LumaInterpreter.LumaFunction": ...

    def runsubprogram(
        self, subprogram: str, Object: "LumaInterpreter | LumaInterpreter.InstancedLumaObject | None" = None, infunc: bool = True, realfunc: bool = False, line1: int = 1, file: str = ""
    ): ...

    def process(
        self,
        line: str,
        linenum: int,
        Object: "LumaInterpreter | LumaInterpreter.InstancedLumaObject | None" = None,
        file: str = '',
    ) -> EvaluatedType | None: ...

    @staticmethod
    def throw(
        exc: "LumaInterpreter.LumaClass",
        msg: "str | LumaInterpreter.InstancedLumaObject",
    ) -> NoReturn: ...

    def processcondition(self, condition: str) -> list[EvaluatedType | str]: ...

    def parse_args(self, input_string: str) -> list[dict[str, str | EvaluatedType]]: ...

    def splitbyop(self, expr: str) -> list[str]: ...

    def extractargs(self, line: str, funcname: str) -> list[EvaluatedType]: ...

    @staticmethod
    def termisclosed(term: str) -> bool: ...

    def evaluatecond(self, cond: tuple[EvaluatedType, str, EvaluatedType]) -> "LumaInterpreter.InstancedLumaObject['bool']": ...

    @staticmethod
    def eval_single_condition(parts: tuple[EvaluatedType, str, EvaluatedType]) -> bool: ...

    def is_condition_expression(self, expr: str) -> bool: ...

    @staticmethod
    def get_oldest_parent(cls: type) -> type: ...

    @staticmethod
    def smrtsplt(expr: str, sep: str) -> list[str]: ...

    @staticmethod
    def namourtype(obj: EvaluatedType) -> str: ...

    @staticmethod
    def is_obj_call(expr: str) -> bool: ...

    @staticmethod
    def copy_dict(d: dict) -> dict: ...

    def evaluate(
        self, expr: str, evalforwhat: str | None = None, doyouwantit: bool = False, line: int = 0
    ) -> EvaluatedType: ...

    class LumaClass:
        def __init__(self, name: str, parents: list[str] = []): ...

        def __lbool__(self) -> bool: ...

        def __repr__(self) -> str: ...

        def __eq__(self, other: "EvaluatedType | LumaInterpreter.LumaClass") -> bool: ...

        def call(self, args: list[EvaluatedType]) -> NoReturn: ...

        def instance(self, args: list[EvaluatedType]) -> "LumaInterpreter.InstancedLumaObject": ...

    class LumaFunction:
        def __init__(
            self,
            name: str,
            args: list[dict[str, str | EvaluatedType]],
            body: str | Callable[[Any], Any],
            line: int,
            file: str,
        ):  ...

        def run(
            self, args: list[EvaluatedType], Object: "LumaInterpreter | LumaInterpreter.InstancedLumaObject" = None, varsholder: "LumaInterpreter | LumaInterpreter.InstancedLumaObject" = None
        ) -> EvaluatedType: ...

        def call(self, args: list[EvaluatedType]) -> EvaluatedType: ...

        def __repr__(self) -> str: ...

        def bind_values(self, args: list[EvaluatedType]) -> dict[str, EvaluatedType]: ...

    class LumaClassDict(LumaClass):
        def __init__(self, name: str, parents: list[str] = []): ...

        @staticmethod
        def lbool(
            value: "LumaInterpreter.InstancedLumaObject",
        ) -> "Any | LumaInterpreter.InstancedLumaObject": ...

    class LumaClassStr(LumaClass):
        def __init__(self, name: str, parents: list[str] = []): ...

    class InstancedLumaObject[ClassName: LiteralString]:
        def __init__(
            self,
            varis: dict[EvaluatedType],
            functions: "dict[str, LumaInterpreter.LumaFunction]",
            classes: "dict[str, LumaInterpreter.LumaClass]",
            name: ClassName,
            args: list[EvaluatedType],
            parents: list[str],
        ): ...

        def call(self, args: list[EvaluatedType], line: int) -> EvaluatedType: ...

        def tie(self, method: str) -> "LumaInterpreter.LumaFunction": ...

        def callmethod(self, method: str, args: list[EvaluatedType]): ...

        def instance(self, args: list[EvaluatedType]): ...

        def __str__(self) -> str: ...

        def __lbool__(self) -> "Any | LumaInterpreter.InstancedLumaObject": ...

        def __bool__(self) -> bool: ...

        def __eq__(self, other: EvaluatedType) -> bool: ...

        def __ne__(self, other: EvaluatedType) -> bool: ...

        def __lt__(self, other: EvaluatedType) -> bool: ...

        def __le__(self, other: EvaluatedType) -> bool: ...

        def __gt__(self, other: EvaluatedType) -> bool: ...

        def __ge__(self, other: EvaluatedType) -> bool: ...

        def __int__(self) -> int: ...

        def __hash__(self) -> int: ...

    class SubProgramExitCode(Exception):
        def __init__(self, code, data=None): ...

    class LumaException(Exception):
        def __init__(self, exc: "LumaInterpreter.InstancedLumaObject"): ...
        def display(self, tbline: tuple[int, str, str]): ...
